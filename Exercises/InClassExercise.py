{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "3bbf3981",
   "metadata": {},
   "source": [
    "# Exercise 1: Explanatory Data Analysis \n",
    "\n",
    "This exercise will give you experience in parsing and exploring the IMDb dataset, which we will use throughout the semester.\n",
    "\n",
    "Download the IMDb dataset Download IMDb dataset for this class\n",
    "Use Python's JSON package to parse this dataset\n",
    "Identify the top ten most frequent actors in the dataset\n",
    "Identify the top ten most frequent genres in the dataset\n",
    "Identify the top ten highest rated films in the dataset\n",
    "Identify the top ten films with the most votes in the dataset\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "78aac800",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Top 10 Most Frequent Actors:\n",
      "Eric Roberts: 194\n",
      "Michael Madsen: 98\n",
      "Tom Sizemore: 97\n",
      "Danny Trejo: 88\n",
      "Tony Devon: 75\n",
      "Joe Hammerstone: 71\n",
      "Dean Cain: 63\n",
      "James Franco: 63\n",
      "Bruce Willis: 61\n",
      "Nicolas Cage: 61\n",
      "\n",
      "Top 10 Most Frequent Genres:\n",
      "Drama: 10157\n",
      "Comedy: 6017\n",
      "Thriller: 4004\n",
      "Action: 3743\n",
      "Horror: 3077\n",
      "Crime: 2773\n",
      "Romance: 2521\n",
      "Adventure: 1667\n",
      "Mystery: 1535\n",
      "Sci-Fi: 1055\n",
      "\n",
      "Top 10 Highest Rated Films:\n",
      "King James: 9.8\n",
      "Tutankhamun: Enter the Tomb: 9.7\n",
      "Cuando volveras: 9.7\n",
      "Detroit Under S.T.R.E.S.S.: 9.7\n",
      "Indocumentados: 9.6\n",
      "Controlled: 9.6\n",
      "All Hail the Popcorn King: 9.6\n",
      "Trust: 9.6\n",
      "As If They Were Angels: 9.6\n",
      "The Bed-Sitting Room: 9.6\n",
      "\n",
      "Top 10 Films with Most Votes:\n",
      "The Dark Knight: 2,667,724 votes\n",
      "Inception: 2,366,510 votes\n",
      "The Lord of the Rings: The Fellowship of the Ring: 1,885,329 votes\n",
      "The Lord of the Rings: The Return of the King: 1,855,813 votes\n",
      "Interstellar: 1,849,404 votes\n",
      "The Dark Knight Rises: 1,714,068 votes\n",
      "The Lord of the Rings: The Two Towers: 1,675,772 votes\n",
      "Django Unchained: 1,565,543 votes\n",
      "Gladiator: 1,509,148 votes\n",
      "Batman Begins: 1,479,441 votes\n"
     ]
    }
   ],
   "source": [
    "import json\n",
    "from collections import Counter\n",
    "\n",
    "# function to read through the JSON file and load it\n",
    "\n",
    "def read_imdb_data(filename):\n",
    "    with open(filename, \"r\") as file_connection:\n",
    "        data = [json.loads(line) for line in file_connection] # also can use data.append after creating empty list of data to loop through\n",
    "    return data\n",
    "\n",
    "# initializing the dataset with the function\n",
    "\n",
    "imdb_data = read_imdb_data(\"imdb_movies_2000to2022.prolific.json\")\n",
    "\n",
    "# function for top ten most frequent actors\n",
    "\n",
    "def get_top_actors(data):\n",
    "    actor_counts = Counter()\n",
    "    for movie in data:\n",
    "        if \"actors\" in movie and isinstance(movie[\"actors\"], list): # loop through if actors are in the outer list  \n",
    "            for top_actors in movie[\"actors\"]:\n",
    "                if isinstance(top_actors, list) and len(top_actors) >= 2: # insurance check to drop otherwise empty nested inner list structures\n",
    "                    actor_counts.update([top_actors[1]]) # 2nd element of list is actor name, getting these counts and returning most common 10\n",
    "    return actor_counts.most_common(10)\n",
    "\n",
    "# function for top ten most frequent genres\n",
    "\n",
    "def get_top_genres(data):\n",
    "    genre_counts = Counter()\n",
    "    for movie in data: \n",
    "        if \"genres\" in movie and isinstance(movie[\"genres\"], list): # loop through and check to make sure it's a list\n",
    "            genre_counts.update(movie[\"genres\"]) # getting genre element (only element) of the list and returning most common 10\n",
    "    return genre_counts.most_common(10)\n",
    "\n",
    "# function for top ten highest rated films\n",
    "\n",
    "def get_highest_rated_films(data):\n",
    "    high_rated_films = [] # making new list to populate (like a copy)\n",
    "    for movie in data:\n",
    "        if \"rating\" in movie and isinstance(movie[\"rating\"], dict): # checking to make sure it's a dictionary with a rating inside of it\n",
    "            rating = movie[\"rating\"].get(\"avg\") # getting values of the ratings\n",
    "            if rating is not None:\n",
    "                high_rated_films.append((movie['title'], rating)) # if rating exists append the results to the list alongside the movie title \n",
    "    \n",
    "    high_rated_films.sort(key=lambda x: x[1], reverse=True) # top 10 descending order based on the second element of the list returned (ratings)\n",
    "    return high_rated_films[:10]\n",
    "\n",
    "# function for top ten films with most votes\n",
    "\n",
    "def get_most_voted_films(data):\n",
    "    voted_films = [] # making a new list to populate (like a copy)\n",
    "    for movie in data:\n",
    "        if \"rating\" in movie and isinstance(movie[\"rating\"], dict): # checking to make sure it's a dictionary with a rating (shares the same dictionary as the movie votes)\n",
    "            votes = movie[\"rating\"].get(\"votes\") # getting value of the votes in dict\n",
    "            if votes is not None:\n",
    "                voted_films.append((movie[\"title\"], votes)) # if rating exists append the results to the list alongside the movie title\n",
    "    \n",
    "    voted_films.sort(key=lambda x: x[1], reverse=True) # top 10 descending order based on the second element of the list returned (votes)\n",
    "    return voted_films[:10]\n",
    "\n",
    "# calling functions in easily readable format (comma formatting and floating points)\n",
    "\n",
    "print(\"\\nTop 10 Most Frequent Actors:\")\n",
    "for actor, count in get_top_actors(imdb_data):\n",
    "    print(f\"{actor}: {count}\")\n",
    "\n",
    "print(\"\\nTop 10 Most Frequent Genres:\")\n",
    "for genre, count in get_top_genres(imdb_data):\n",
    "    print(f\"{genre}: {count}\")\n",
    "\n",
    "print(\"\\nTop 10 Highest Rated Films:\")\n",
    "for title, rating in get_highest_rated_films(imdb_data):\n",
    "    print(f\"{title}: {rating:.1f}\")\n",
    "\n",
    "print(\"\\nTop 10 Films with Most Votes:\")\n",
    "for title, votes in get_most_voted_films(imdb_data):\n",
    "    print(f\"{title}: {votes:,} votes\")\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "917ae4c0",
   "metadata": {},
   "source": [
    "# Exercise 2: Finding Genre-Bending Hits [Optional]\n",
    "\n",
    "Using the IMDb dataset, find the top three highest rated genre pairs (e.g., find the average rating of a Dramedy/drama + comedy or a Romantasy/Romance + fantasy film)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "d7ac3f49",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Top 3 Highest Rated Genre Pairs (minimum of 20 movies for genre pair):\n",
      "1. Documentary + Sport: 7.50 (based on 45 movies)\n",
      "2. Documentary + History: 7.36 (based on 91 movies)\n",
      "3. Documentary + Drama: 7.19 (based on 34 movies)\n"
     ]
    }
   ],
   "source": [
    "def find_top_genre_pairs(data):\n",
    "\n",
    "# creating genre pairs and pair_count lists for later calculations of average genre pair rating \n",
    "\n",
    "    genre_pairs = {}\n",
    "    pair_count = {}\n",
    "    \n",
    "# looping through data and doing type checks before getting and assigning rating values \n",
    "\n",
    "    for movie in data:\n",
    "        if ('genres' in movie and isinstance(movie['genres'], list) and \n",
    "            'rating' in movie and isinstance(movie['rating'], dict)):\n",
    "            rating = movie['rating'].get('avg')\n",
    "            if rating is not None and len(movie['genres']) >= 2: # looping through and checking for rating existence and genre existence before assigning movie genres\n",
    "                genres = movie['genres']\n",
    "                \n",
    "                # nested loop through all possible genre pairs (no repetition or self-pairing, i --> first genre, j --> genre after that to make pair)\n",
    "                for i in range(len(genres)): \n",
    "                    for j in range(i + 1, len(genres)):\n",
    "                        pair = tuple(sorted([genres[i], genres[j]])) # sorted tuple to hold genre pair without duplicates due to order changes\n",
    "                        \n",
    "                        if pair not in genre_pairs: # if genre pair not already there, 2 dictionaries are initialized\n",
    "                            genre_pairs[pair] = 0 # sum of ratings for specific genre pair \n",
    "                            pair_count[pair] = 0 # keeping track of movies that have this genre pair\n",
    "                        \n",
    "                        genre_pairs[pair] += rating # adding movie rating for each specific genre pair\n",
    "                        pair_count[pair] += 1 # increasing movie count by 1 everytime the same genre pair shows up\n",
    "    \n",
    "    # making empty genre pairs dict populated with minimum number of 20 movies to be included in the final calculations \n",
    "    filtered_pairs = {}\n",
    "    for pair in genre_pairs:\n",
    "        if pair_count[pair] >= 20: # helps make the top 3 movies more accurate representation of what people actually enjoy more (rather than accounting for too many or too little, good middleground)\n",
    "            filtered_pairs[pair] = genre_pairs[pair] / pair_count[pair] # getting average ratings of genre pairs (sum of ratings / 20 or more movies)\n",
    "    \n",
    "    # sort by computed average rating from filtered list\n",
    "    sorted_pairs = sorted(filtered_pairs.items(), key=lambda x: x[1], reverse=True) # second element (avg rating) in descending order\n",
    "    \n",
    "    return [(pair, avg_rating, pair_count[pair]) for pair, avg_rating in sorted_pairs[:3]] # return top 3 movie genre pairs alongside the number of movies for that specific pair \n",
    "\n",
    "print(\"\\nTop 3 Highest Rated Genre Pairs (minimum of 20 movies for genre pair):\")\n",
    "\n",
    "top_genre_pairs = find_top_genre_pairs(imdb_data)\n",
    "\n",
    "for i, (pair, rating, count) in enumerate(top_genre_pairs, 1): # start list at 1, loop through genre pairs, avg rating, and genre pair counts for the given output of the function\n",
    "    genre1, genre2 = pair\n",
    "    print(f\"{i}. {genre1} + {genre2}: {rating:.2f} (based on {count} movies)\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
